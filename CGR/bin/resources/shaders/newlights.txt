
/*
uniform vec3 materialAlbedo = vec3(1.0);
uniform float materialReflectance = 0.2f;
uniform float materialConductivity = 0.1f;
uniform float materialRoughness = 1.0f;

vec3 halfVector (in vec3 l, in vec3 v)
{
    return normalize (l + v);
}

vec3 blinnPhongSpecular (in vec3 l, in vec3 n, in vec3 v)
{
    // First we need to interpret PBS parameters for shading.
    vec3  albedo          = materialAlbedo;
    float luminosity      = albedo.r * 0.2126f + albedo.g * 0.7151f + albedo.b * 0.0722f;
    vec3  specularColour  = mix (vec3 (materialReflectance), vec3 (luminosity), materialConductivity);

    float shininess       = ((2.0 / pow (materialRoughness, 2.0)) - 2.0) * 4.0;

    // Using the half vector we can calculate the specularity of a surface.
    return shininess > 0.0 ? 
        specularColour * pow (max (dot (halfVector (l, v), n), 0.0), shininess) 
        : vec3 (0.0);
}

vec3 lambertDiffuse (in float lDotN)
{
    return materialAlbedo * lDotN;
}

vec3 calculateReflectance (in vec3 l, in vec3 n, in vec3 v, in vec3 e)
{
    // Determine whether we can actually light the surface.
    float lDotN = max (dot (l, n), 0.0);

    if (lDotN == 0.0)
    {
        return vec3 (0.0);
    }
    
    return e * (lambertDiffuse (lDotN) + blinnPhongSpecular (l, n, v));
}

vec3 pointLight(PointLight light, in vec3 normal, in vec3 view)
{
    // We'll need the distance and direction from the light to the surface for attenuation.
    vec3  bigL    = light.Position - varying_position;
    float dist    = length (bigL);
    vec3  l       = bigL / dist;

	float range = 10.0f;
	
    // Point light attenuation formula is: 1 / (Kc + Kl * d + Kq * d * d).
    float attenuation = range >= dist ? 
        1.0 / (light.Atten.Constant + light.Atten.Linear * dist + light.Atten.Exp * dist * dist) : 0.0;

    // Scale the intensity accordingly.
    vec3 E = vec3(light.Base.DiffuseIntensity) * attenuation;
    
    return calculateReflectance (l, normal, view, E);
}
*/

  